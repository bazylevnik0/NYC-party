<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>campfire</title>
    <style>
      body {
        margin: 0;
      }
    </style>
  </head>
  <body>
    <button id="exit">EXIT</button>
    <button id="audiorecord">record</button>
    <button id="audiostop">stop</button>
    <input  id="passphrase" value="42"></input>
  </body>
  <script src="/socket.io.js"></script>
  <script src="/openpgp.js"></script>
  <script type="module">
    import * as THREE from "/three.module.js";

    // Parse nickname, avatar, id from URL
    var guest = {};
    let params = new URLSearchParams(window.location.search);
        guest.nickname   = params.get("nickname");
        guest.avatar     = params.get("avatar");
        guest.id         = params.get("id");
        guest.passphrase = Math.random(); // sort of "the session generating seed"

    // Generate the guest keys, store keys
    (async () => {
    let { privateKey, publicKey } = await openpgp.generateKey({
        type: 'rsa',
        rsaBits: 4096,
        userIDs: [{ nickname: guest.nickname, avatar: guest.avatar, id: guest.id }],
        passphrase: guest.passphrase,
    });
    guest.public_key  = publicKey;
    guest.private_key = privateKey;

    // Register the public key with guest information
    let url_register =
        location.protocol +
        "//" +
        location.host +
        "/register";
    let xml_register = new XMLHttpRequest();
    xml_register.open("POST", url_register);
    xml_register.setRequestHeader('Content-Type', 'application/json;charset=UTF-8')
    xml_register.send(JSON.stringify({
            nickname: guest.nickname,
            avatar: guest.avatar,
            id: guest.id,
            public_key: guest.public_key
    }));
    })();

    // Controls UI
    // Exit
    let button_exit = document.getElementById("exit");
    button_exit.addEventListener("click", () => {
    // Generate signature to verify exit action
      (async () => {
        let publicKey  = await openpgp.readKey({ armoredKey: guest.public_key });
        let privateKey = await openpgp.readPrivateKey({ armoredKey: guest.private_key });

        let message = await openpgp.createMessage({ text: 'exit' });
        let detachedSignature = await openpgp.sign({
          message,
          signingKeys: privateKey,
          detached : true
        });
        // Send signature - request of deleting from server
        let url_exit =
            location.protocol +
            "//" +
            location.host +
            "/exit";
        let xml_exit = new XMLHttpRequest();
        xml_exit.open("POST", url_exit);
        xml_exit.setRequestHeader('Content-Type', 'application/json;charset=UTF-8')
        xml_exit.send(JSON.stringify({
                id: guest.id,
                message: JSON.stringify(detachedSignature)
        }));

        window.location = location.protocol + "//" + location.host;
       })();
    });

    // Rendering of 3D
    var graphics = {};
    graphics.scene = new THREE.Scene();
    graphics.camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    graphics.camera.position.z = 5;
    graphics.renderer = new THREE.WebGLRenderer();
    graphics.renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(graphics.renderer.domElement);
    graphics.animate = function () {
      graphics.renderer.render(graphics.scene, graphics.camera);
    }
    graphics.renderer.setAnimationLoop(graphics.animate);

    // Information about guests(avatars which on the party)
    var guests = {};
        guests.data      = [];
        guests.data_prev = [];
    // Models of avatars
    var models = {};
        models.geometries = {};
        models.materials  = {};
        models.cubes   = {};
        models.objects = [];

    guests.get = async function () {
      // Fetching from server information about existence of guests
      let url_get = location.protocol + "//" + location.host + "/guests_get";
      try {
        let response = await fetch(url_get);
        if (!response.ok) {
          throw new Error(`Response status: ${response.status}`);
        }
        guests.data = await response.json();
        // Exist changes in the guests?
        if (JSON.stringify(guests.data_prev) === JSON.stringify(guests.data)) {
          return false;
        } else {
          guests.data_old = guests.data;
          return true;
        }
      } catch (error) {
        console.error(error.message);
      }
    };

    // Load models for each type of avatar
    let models_dict = ["human", "robot", "sceleton", "zombie", "ghost"];
    for (let i = 0; i < models_dict.length; i++) {
       models.geometries[models_dict[i]] = new THREE.BoxGeometry(1, 1, 1);
       switch (models_dict[i]) {
          case "human"   : models.materials[models_dict[i]] = new THREE.MeshBasicMaterial({color: 0xff0000,}); break;
          case "robot"   : models.materials[models_dict[i]] = new THREE.MeshBasicMaterial({color: 0x00ff00,}); break;
          case "sceleton": models.materials[models_dict[i]] = new THREE.MeshBasicMaterial({color: 0x0000ff,}); break;
          case "zombie"  : models.materials[models_dict[i]] = new THREE.MeshBasicMaterial({color: 0xffff00,}); break;
          case "ghost"   : models.materials[models_dict[i]] = new THREE.MeshBasicMaterial({color: 0xff00ff,}); break;
       }
       models.cubes[models_dict[i]] =  new THREE.Mesh(
                                          models.geometries[models_dict[i]],
                                          models.materials[models_dict[i]]
                                       );
    }

    models.build = function () {
      // Delete old models from scene and add again with new information
      for (let i = 0; i < models.objects.length; i++) {
        graphics.scene.remove(models.objects[i]);
      }
      for (let i = 0; i < guests.data.length; i++) {
        let model;
        switch (guests.data[i].avatar) {
          case "human"    :  models.objects[i] = models.cubes.human.clone();    break;
          case "robot"    :  models.objects[i] = models.cubes.robot.clone();    break;
          case "sceleton" :  models.objects[i] = models.cubes.sceleton.clone(); break;
          case "zombie"   :  models.objects[i] = models.cubes.zombie.clone();   break;
          case "ghost"    :  models.objects[i] = models.cubes.ghost.clone();    break;
        }
        models.objects[i].position.x = i * 2 - 4;
        graphics.scene.add(models.objects[i]);
      }
    }

    // Refresh information about guests each 1 sec and if needed build 3D models
    guests.interval = setInterval ( ()=> {
      let check = guests.get();
      if (check) models.build();
    }, 1000);


    // Streaming of audio record (microphon)
    let button_record = document.getElementById("audiorecord");
    let button_stop = document.getElementById("audiostop");
    let input_passphrase = document.getElementById("passphrase");

    var socket = io();
    var mediaRecorder; let chunks = [];
    // Ask permission
    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      navigator.mediaDevices
        .getUserMedia(
           {
            audio: true,
          }
        )

        // If success
        .then((stream) => {
          mediaRecorder = new MediaRecorder(stream);
          mediaRecorder.addEventListener("dataavailable", (stream) => {
            // Temporary store chunks while mediaRecorder is active
            chunks.push(stream.data);
          });
          button_record.addEventListener("click", () => {
             // Set mediarecorder - active
             mediaRecorder.start(100);
          });

          button_stop.addEventListener("click", () => {
            (async () => {
              // Set mediarecorder - inactive
              mediaRecorder.stop();
              // Convert the stream data to array and send to server with encryption
              let blob = new Blob(chunks, { type: "audio/ogg; codecs=opus" });
              let buffer = await blob.arrayBuffer();
              let message =  await openpgp.createMessage({binary: new Uint8Array(buffer)});
              openpgp.encrypt({
                  message,
                  passwords: [input_passphrase.value],
                  format: 'binary'
              }).then ( (encrypted)=> {
                 socket.emit('stream_audio',JSON.stringify(encrypted));
              });
              chunks = [];
            })();
          });
        })
        .catch((err) => {
          console.error(`The following getUserMedia error occurred: ${err}`);
        });
    } else {
      console.log("getUserMedia not supported on your browser!");
    }

  // Listen socket broadcast
  socket.on('broadcast_audio', function(data) {
    (async () => {
      // Decrypt message
      const encryptedMessage = await openpgp.readMessage({
          binaryMessage: new Uint8Array(Object.values(JSON.parse(data)))
      });
      const decrypted  = await openpgp.decrypt({
          message: encryptedMessage,
          passwords: [input_passphrase.value],
          format: 'binary'
      });
      // Play audio message
      let blob = new Blob([new Uint8Array(decrypted.data).buffer], { type: "audio/ogg; codecs=opus" });
      var url = await URL.createObjectURL( blob );
      var audio = new Audio();
      audio.src = url;
      audio.play();
    })();
  });
  </script>
</html>
