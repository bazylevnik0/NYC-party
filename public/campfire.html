<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>My first three.js app</title>
    <style>
      body {
        margin: 0;
      }
    </style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@v0.149.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@v0.149.0/examples/jsm/",
        }
      }
    </script>
  </head>
  <body>
    <button id="exit">EXIT</button>
    <button id="audiorecord">record</button>
    <button id="audiostop">stop</button>
  </body>
  <script src="/openpgp.min.js"></script>
  <script type="module">
    // Parse nickname, avatar, id from URL
    let params = new URLSearchParams(window.location.search);
    var guest = {};
        guest.nickname = params.get("nickname");
        guest.avatar   = params.get("avatar");
        guest.id       = params.get("avatar");
    // Generate keys, store keys, and register public key with
    (async () => {
    const { privateKey, publicKey } = await openpgp.generateKey({
        type: 'rsa',
        rsaBits: 4096,
        userIDs: [{ nickname: guest.nickname, avatar: guest.avatar, id: guest.id }]
    });
    console.log(publicKey);
    guest.public_key  = publicKey;
    guest.private_key = privateKey;
    let url_register =
        location.protocol +
        "//" +
        location.host +
        "/register";
    let xml_register = new XMLHttpRequest();
    xml_register.open("POST", url_register);
    xml_register.setRequestHeader('Content-Type', 'application/json;charset=UTF-8')
    xml_register.send(JSON.stringify({
            nickname: guest.nickname,
            avatar: guest.avatar,
            id: guest.id,
            public_key: guest.public_key
    }));
    })();

    /*
    import * as THREE from "three";

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );

    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setAnimationLoop(animate);
    document.body.appendChild(renderer.domElement);

    var guests = {};
    guests.geometries = [];
    guests.materials = [];
    guests.cubes = [];
    guests.data = [];
    guests.data_old = [];
    guests.get_data = async function () {
      const url = location.protocol + "//" + location.host + "/data";
      try {
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`Response status: ${response.status}`);
        }
        guests.data = await response.json();
        guests.build();
        console.log("guests.data: ", guests.data);
      } catch (error) {
        console.error(error.message);
      }
    };
    guests.get_data();

    guests.build = function () {
      guests.geometries = [];
      guests.materials = [];
      for (let i = 0; i < guests.cubes; i++) {
        scene.remove(guests.cubes[i]);
      }
      for (let i = 0; i < guests.data.length; i++) {
        guests.geometries[i] = new THREE.BoxGeometry(1, 1, 1);
        switch (guests.data[i].avatar) {
          case "human":
            guests.materials[i] = new THREE.MeshBasicMaterial({
              color: 0xff0000,
            });
            break;
          case "robot":
            guests.materials[i] = new THREE.MeshBasicMaterial({
              color: 0x00ff00,
            });
            break;
          case "sceleton":
            guests.materials[i] = new THREE.MeshBasicMaterial({
              color: 0x0000ff,
            });
            break;
          case "zombie":
            guests.materials[i] = new THREE.MeshBasicMaterial({
              color: 0xffff00,
            });
            break;
          case "ghost":
            guests.materials[i] = new THREE.MeshBasicMaterial({
              color: 0xff00ff,
            });
            break;
        }
        guests.cubes[i] = new THREE.Mesh(
          guests.geometries[i],
          guests.materials[i]
        );
        guests.cubes[i].position.x = i * 2;
        scene.add(guests.cubes[i]);
      }
    };
    guests.data_check = async function () {
      const url = location.protocol + "//" + location.host + "/data";
      try {
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`Response status: ${response.status}`);
        }
        let answer = await response.json();
        guests.data = answer.guests;
        if (JSON.stringify(guests.data_old) === JSON.stringify(guests.data)) {
          return false;
        } else {
          guests.data_old = guests.data;
          return true;
        }
      } catch (error) {
        console.error(error.message);
      }
    };
    let check = guests.data_check();
    guests.data_interval = setInterval(() => {
      check = guests.data_check();
      if (check) guests.build();
    }, 1000);

    camera.position.z = 5;

    function animate() {
      renderer.render(scene, camera);
    }

    let params = new URLSearchParams(window.location.search);
    let nickname = params.get("nickname");
    let avatar = params.get("avatar");
    console.log(nickname, avatar);

    let button_exit = document.getElementById("exit");
    button_exit.addEventListener("click", () => {
      window.location =
        location.protocol + "//" + location.host + "/exit?nickname=" + nickname;
    });

    let button_record = document.getElementById("audiorecord");
    let button_stop = document.getElementById("audiostop");
    var mediaRecorder;
    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      console.log("getUserMedia supported.");
      navigator.mediaDevices
        .getUserMedia(
          // constraints - only audio needed for this app
          {
            audio: true,
          }
        )

        // Success callback
        .then((stream) => {
          mediaRecorder = new MediaRecorder(stream);
          mediaRecorder.addEventListener("dataavailable", (event) => {
            chunks.push(event.data);
          });
        })

        // Error callback
        .catch((err) => {
          console.error(`The following getUserMedia error occurred: ${err}`);
        });
    } else {
      console.log("getUserMedia not supported on your browser!");
    }

    let chunks = [];
    let time = 1;
    let time_interval;
    button_record.addEventListener("click", () => {
      console.log("record");

      //chunks = [];
      time = 1;
      mediaRecorder.start(100);
      console.log(mediaRecorder.state);
      console.log("recorder started");
      time_interval = setInterval(() => {
        time++;
      }, 1000);
    });
    button_stop.addEventListener("click", () => {
      console.log("stop");
      mediaRecorder.stop();
      //need blob converter
      guests.say();
      clearInterval(time_interval);
      console.log(mediaRecorder.state);
      console.log("recorder stopped");
    });
    guests.say = async function () {
      const blob = new Blob(chunks, { type: "audio/ogg; codecs=opus" });
      const buffer = await blob.arrayBuffer();
      //need to shape body of request or change the type!
       let url =
        location.protocol +
        "//" +
        location.host +
        "/say";
      console.log(url);
      let xmlHttp = new XMLHttpRequest();
      xmlHttp.open("POST", url, false); // false for synchronous request
      xmlHttp.setRequestHeader('Content-Type', 'application/json;charset=UTF-8')
      xmlHttp.send(JSON.stringify({
                          data: JSON.stringify(Array.from(new Uint8Array(buffer))),
                          time: JSON.stringify(time),
                          }));
    };
    guests.get_data();
    */
  </script>
</html>
